import time
import board
import adafruit_mpu6050
from gpiozero import Servo
from collections import deque

# =================================================================
# --- CONFIGURATION ---
# =================================================================
# MPU6050 Settings
FORWARD_THRESHOLD_MS2 = 1.5   # m/s^2
REVERSE_THRESHOLD_MS2 = -1.5  # m/s^2

# Servo Settings
SERVO_PIN = 17                
DOOR_OPEN_ANGLE = 90          
DOOR_CLOSED_ANGLE = 0         

# Stability and Timer Settings
# How many consecutive readings we need to confirm a direction change.
DIRECTION_CONFIRMATION_COUNT = 5
# How many seconds to wait before closing the door when stationary.
STATIONARY_TIMEOUT_S = 30 

# =================================================================
# --- INITIALIZATION ---
# =================================================================
# Setup I2C and MPU6050 Sensor
try:
    i2c = board.I2C()
    mpu = adafruit_mpu6050.MPU6050(i2c)
    print("‚úÖ MPU6050 sensor setup complete.")
except Exception as e:
    print(f"‚ùå Failed to initialize MPU6050: {e}")
    print("Please check I2C connections and configuration. Exiting.")
    exit()

# Setup Servo
try:
    servo = Servo(SERVO_PIN, min_pulse_width=0.5/1000, max_pulse_width=2.5/1000)
    print(f"‚úÖ Servo on GPIO {SERVO_PIN} initialized.")
except Exception as e:
    print(f"‚ùå Failed to initialize servo: {e}")
    print("Please check the GPIO pin number and connections. Exiting.")
    exit()
    
def initialize_door():
    """Sets the door to the known 'closed' position at startup."""
    print("‚öôÔ∏è  Initializing door to CLOSED position...")
    servo.angle = DOOR_CLOSED_ANGLE
    time.sleep(1)
    print("‚úÖ Door initialization complete.")

# =================================================================
# --- MAIN LOGIC ---
# =================================================================

# State can be "FORWARD", "REVERSING", or "STATIONARY".
# This tracks the last confirmed state of the vehicle's motion.
last_vehicle_state = "FORWARD" 

# NEW: A variable to store the timestamp of when the vehicle stopped.
# We set it to None when the vehicle is moving.
stationary_start_time = None

# Use a 'deque' for an efficient, fixed-size list to store recent readings
recent_directions = deque(maxlen=DIRECTION_CONFIRMATION_COUNT)

# Set the initial door position
initialize_door()

print("\nüöÄ Starting main loop. Monitoring for vehicle movement...")

while True:
    try:
        accel_x, _, _ = mpu.acceleration
        
        # 1. Determine immediate direction from this single reading
        immediate_direction = "STATIONARY"
        if accel_x > FORWARD_THRESHOLD_MS2:
            immediate_direction = "FORWARD"
        elif accel_x < REVERSE_THRESHOLD_MS2:
            immediate_direction = "REVERSING"
        
        recent_directions.append(immediate_direction)
        
        # We only proceed if the stability buffer is full
        if len(recent_directions) < DIRECTION_CONFIRMATION_COUNT:
            continue

        # 2. Confirm the direction only if all recent readings are the same
        confirmed_direction = recent_directions[0] if all(d == recent_directions[0] for d in recent_directions) else None
        
        if confirmed_direction is None:
            # Readings are inconsistent (e.g., bumpy road), so do nothing.
            continue
            
        # 3. State Change and Timer Logic
        
        # CASE A: The vehicle is moving (Forward or Reverse)
        if confirmed_direction != "STATIONARY":
            # If the state is new, act on it.
            if confirmed_direction != last_vehicle_state:
                if confirmed_direction == "REVERSING":
                    print("Vehicle is REVERSING. Opening door...")
                    servo.angle = DOOR_OPEN_ANGLE
                elif confirmed_direction == "FORWARD":
                    print("Vehicle is moving FORWARD. Closing door...")
                    servo.angle = DOOR_CLOSED_ANGLE
                
                last_vehicle_state = confirmed_direction
            
            # Since the vehicle is moving, ensure the stationary timer is reset.
            if stationary_start_time is not None:
                print("Vehicle is moving again, cancelling stationary timer.")
                stationary_start_time = None

        # CASE B: The vehicle is stationary
        else:
            # If we were just reversing and have now stopped, start the timer.
            if last_vehicle_state == "REVERSING" and stationary_start_time is None:
                print(f"Vehicle stopped. Starting {STATIONARY_TIMEOUT_S}s timer to close door...")
                stationary_start_time = time.time()
            
            # Check if the timer has expired.
            if stationary_start_time is not None and (time.time() - stationary_start_time > STATIONARY_TIMEOUT_S):
                print(f"Stationary for {STATIONARY_TIMEOUT_S}s. Closing door...")
                servo.angle = DOOR_CLOSED_ANGLE
                
                # IMPORTANT: Update state and reset timer to prevent this from running again.
                last_vehicle_state = "FORWARD" # We consider the door closed, so we're in a 'forward' like state.
                stationary_start_time = None

        time.sleep(0.1)

    except OSError as e:
        print(f"‚ö†Ô∏è Warning: Could not read from sensor: {e}. Retrying...")
        time.sleep(1)
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Program stopped by user. Closing door...")
        servo.angle = DOOR_CLOSED_ANGLE
        time.sleep(1)
        servo.close()
        break
